/*=========================================================================
 *
 *  Copyright NumFOCUS
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/
#include <iomanip>
#include "itkImageFileReader.h"
#include "itkImageFileWriter.h"
#include "itkCommand.h"
#include "itkSimpleFilterWatcher.h"

//#include "plotutils.h"

#include "itkGrayscaleDilateImageFilter.h"
#include "itkBinaryBallStructuringElement.h"

#include "itkSmoothingRecursiveGaussianImageFilter.h"
#include "itkBinaryThresholdImageFilter.h"
#include "itkMorphologicalSharpeningImageFilter.h"
#include "itkTimeProbe.h"
#include "itkMultiThreaderBase.h"

int
itkParaSharpenTest(int argc, char * argv[])
{
  int iterations = 1;

  if (argc != 3)
  {
    std::cerr << "Usage: " << argv[0] << " iterations outputimage " << std::endl;
    return (EXIT_FAILURE);
  }

  iterations = std::stoi(argv[1]);

  // itk::MultiThreaderBase::SetGlobalMaximumNumberOfThreads( 1 );
  constexpr int dim = 2;

  using PType = unsigned char;
  using IType = itk::Image<PType, dim>;
  using FType = itk::Image<float, dim>;

  using WriterType = itk::ImageFileWriter<IType>;
  WriterType::Pointer writer = WriterType::New();

  // create the input image - we will blur a dot, threshold then blur again
  IType::Pointer     input = IType::New();
  IType::SizeType    size;
  IType::IndexType   index;
  IType::RegionType  region;
  IType::SpacingType spacing;

  size.Fill(100);
  spacing.Fill(1);
  region.SetSize(size);

  index.Fill(50);

  input->SetRegions(region);
  input->SetSpacing(spacing);
  input->Allocate();

  input->FillBuffer(0);
  input->SetPixel(index, 255);

  using SRType = itk::BinaryBallStructuringElement<PType, dim>;
  using DilateType = itk::GrayscaleDilateImageFilter<IType, IType, SRType>;
  DilateType::Pointer smallDilate = DilateType::New();
  SRType              smallkernel;
  SRType::RadiusType  smallrad = smallkernel.GetRadius();
  smallrad.Fill(7);
  smallkernel.SetRadius(smallrad);
  smallkernel.CreateStructuringElement();
  smallDilate->SetKernel(smallkernel);

  using SmootherType = itk::SmoothingRecursiveGaussianImageFilter<IType, IType>;

  SmootherType::Pointer smoother = SmootherType::New();

  smallDilate->SetInput(input);

  smoother->SetInput(smallDilate->GetOutput());
  smoother->SetSigma(3);

  writer->SetInput(smallDilate->GetOutput());
  writer->SetFileName("input.tif");
  try
  {
    writer->Update();
  }
  catch (itk::ExceptionObject & excp)
  {
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
  }

  writer->SetInput(smoother->GetOutput());
  writer->SetFileName("blurrredinput.tif");
  try
  {
    writer->Update();
  }
  catch (itk::ExceptionObject & excp)
  {
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
  }

  // now to apply the sharpening

  using FilterType = itk::MorphologicalSharpeningImageFilter<IType, FType>;

  FilterType::Pointer filter = FilterType::New();

  filter->SetInput(smoother->GetOutput());
  filter->SetScale(1);
  filter->SetIterations(iterations);
  try
  {
    filter->Update();
  }
  catch (itk::ExceptionObject & excp)
  {
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
  }

  using FlWriterType = itk::ImageFileWriter<FType>;
  FlWriterType::Pointer flwriter = FlWriterType::New();

  flwriter->SetInput(filter->GetOutput());
  flwriter->SetFileName(argv[2]);
  try
  {
    flwriter->Update();
  }
  catch (itk::ExceptionObject & excp)
  {
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
  }

#if 0
  // this stuff as for the article
  // write out profiles
  // input
  IType::IndexType first, last;
  first[0] = 50;
  first[1] = 0;
  last[0] = 50;
  last[1] = 99;

  extractProfile< IType >(smallDilate->GetOutput(), first, last, "inputprof.txt");
  extractProfile< IType >(smoother->GetOutput(), first, last, "blurredprof.txt");
  extractProfile< FType >(filter->GetOutput(), first, last, argv[3]);
#endif
  return EXIT_SUCCESS;
}
