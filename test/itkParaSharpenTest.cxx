/*=========================================================================
 *
 *  Copyright Insight Software Consortium
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0.txt
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *=========================================================================*/
#include <iomanip>
#include "itkImageFileReader.h"
#include "itkImageFileWriter.h"
#include "itkCommand.h"
#include "itkSimpleFilterWatcher.h"

//#include "plotutils.h"

#include "itkGrayscaleDilateImageFilter.h"
#include "itkBinaryBallStructuringElement.h"

#include "itkSmoothingRecursiveGaussianImageFilter.h"
#include "itkBinaryThresholdImageFilter.h"
#include "itkMorphologicalSharpeningImageFilter.h"
#include "itkTimeProbe.h"
#include "itkMultiThreader.h"

int itkParaSharpenTest(int argc, char *argv[])
{
  int iterations = 1;

  if ( argc != 3 )
    {
    std::cerr << "Usage: " << argv[0] << " iterations outputimage " << std::endl;
    return ( EXIT_FAILURE );
    }

  iterations = atoi(argv[1]);

  //itk::MultiThreader::SetGlobalMaximumNumberOfThreads(1);
  const int dim = 2;

  typedef unsigned char            PType;
  typedef itk::Image< PType, dim > IType;
  typedef itk::Image< float, dim > FType;

  typedef itk::ImageFileWriter< IType > WriterType;
  WriterType::Pointer writer = WriterType::New();

  // create the input image - we will blur a dot, threshold then blur again
  IType::Pointer     input = IType::New();
  IType::SizeType    size;
  IType::IndexType   index;
  IType::RegionType  region;
  IType::SpacingType spacing;

  size.Fill(100);
  spacing.Fill(1);
  region.SetSize(size);

  index.Fill(50);

  input->SetRegions(region);
  input->SetSpacing(spacing);
  input->Allocate();

  input->FillBuffer(0);
  input->SetPixel(index, 255);

  typedef itk::BinaryBallStructuringElement< PType, dim >         SRType;
  typedef itk::GrayscaleDilateImageFilter< IType, IType, SRType > DilateType;
  DilateType::Pointer smallDilate = DilateType::New();
  SRType              smallkernel;
  SRType::RadiusType  smallrad = smallkernel.GetRadius();
  smallrad.Fill(7);
  smallkernel.SetRadius(smallrad);
  smallkernel.CreateStructuringElement();
  smallDilate->SetKernel(smallkernel);

  typedef itk::SmoothingRecursiveGaussianImageFilter< IType, IType > SmootherType;

  SmootherType::Pointer smoother = SmootherType::New();

  smallDilate->SetInput(input);

  smoother->SetInput( smallDilate->GetOutput() );
  smoother->SetSigma(3);

  writer->SetInput( smallDilate->GetOutput() );
  writer->SetFileName("input.tif");
  try
    {
    writer->Update();
    }
  catch ( itk::ExceptionObject & excp )
    {
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
    }

  writer->SetInput( smoother->GetOutput() );
  writer->SetFileName("blurrredinput.tif");
  try
    {
    writer->Update();
    }
  catch ( itk::ExceptionObject & excp )
    {
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
    }

  // now to apply the sharpening

  typedef itk::MorphologicalSharpeningImageFilter< IType, FType > FilterType;

  FilterType::Pointer filter = FilterType::New();

  filter->SetInput( smoother->GetOutput() );
  filter->SetScale(1);
  filter->SetIterations(iterations);
  try
    {
    filter->Update();
    }
  catch ( itk::ExceptionObject & excp )
    {
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
    }

  typedef itk::ImageFileWriter< FType > FlWriterType;
  FlWriterType::Pointer flwriter = FlWriterType::New();

  flwriter->SetInput( filter->GetOutput() );
  flwriter->SetFileName(argv[2]);
  try
    {
    flwriter->Update();
    }
  catch ( itk::ExceptionObject & excp )
    {
    std::cerr << excp << std::endl;
    return EXIT_FAILURE;
    }

#if 0
  // this stuff as for the article
  // write out profiles
  // input
  IType::IndexType first, last;
  first[0] = 50;
  first[1] = 0;
  last[0] = 50;
  last[1] = 99;

  extractProfile< IType >(smallDilate->GetOutput(), first, last, "inputprof.txt");
  extractProfile< IType >(smoother->GetOutput(), first, last, "blurredprof.txt");
  extractProfile< FType >(filter->GetOutput(), first, last, argv[3]);
#endif
  return EXIT_SUCCESS;
}
